//criando uma arvore 28/05
#include<iostream>
using namespace std;

struct Nodo{
    int info;                                //         Nodo          //  
    struct Nodo * esq , * dir;               // * esq  || int || * dir //
};


class Tree{
    public:
    Nodo * raiz; //deixando a raiz como atributo publico
    
    Tree(){
        raiz = nullptr; //inicializando com nullptr
    }
    
    //a função retorna um ponteiro, pois o "link" esta no retorno
    //primeiro elemento da arvore
    Nodo * inserir (Nodo * raiz, int valor){
        if(raiz == nullptr){
            raiz = new Nodo(); //criando uma raiz
            if(raiz == nullptr){
                //verifica alocação
                cout<<"Erro ao alocar o Nodo"<<endl;
                return nullptr;
            }
            //raiz recebe o valor
            raiz->info = valor;
            //ponteiros da direita e esquerda recebem nullptr
            raiz->esq = nullptr;
            raiz->dir = nullptr;
            
            //retorna a raiz
            return raiz;
        }
        //não precisa do else já que tem o return
        // e quando a raiz não for nula? Perguntamos para que lado vamos
        
        //se o valor for maior que a raiz
        if(valor > (raiz->info)){
            //preciso chamar a função pela direita
            raiz->dir = inserir(raiz->dir, valor);
            //ela retorna para a raiz direita! 
        } else{
            //se for menor que a raiz
            if(valor < (raiz->info)){
                //preciso chamar função pela esquerda
                raiz->esquerda = inserir(raiz->esq, valor);
                //ela retorna para a raiz esquerda! 
            } 
            else{
                //se os valores forem iguais 
                cout<<"Numero repetido"<<endl;
            }
            return raiz;
        }
    }

 void inserirSemRecursao (Nodo * raiz, int num){
        
        if(raiz == nullptr){
            raiz = new Nodo();
            raiz = new Nodo(); //criando uma raiz
            if(raiz == nullptr){
                //verifica alocação
                cout<<"Erro ao alocar o Nodo"<<endl;
                return;
            }
            //raiz recebe o valor
            raiz->info = num;
            //ponteiros da direita e esquerda recebem nullptr
            raiz->esq = nullptr;
            raiz->dir = nullptr;
            return;
        }
        
        //criando dois ponteiros auxiliares
        Nodo * atual = nullptr;
        Nodo * pai = nullptr;
        atual = raiz;
        
        //enquanto "atual" for direfente de nullptr        
        while(atual != nullptr){
            pai = atual; // pai vai salvar o local para inseirir
            //perguntar sobre o valor para saber como mecher o atual
            if(num > (atual->info)){
                //se for maior
                atual = atual->dir;
            }
            else{
                //se for menor
                if(num < (atual->info)){
                    atual = atual->esq;
                }
                // se os valores forem iguais
                else{
                    cout<<"Valor Repetido"<<endl;
                    return;
                }
            }
        } //saindo daqui, já sei onde devo colocar o novo Valor
        
        atual = new Nodo();
        if (atual == nullptr){
            cout<<"Erro"<<endl;
            return;
        }
        
        //preenchendo...
        atual->info = num;
        atual->esq = nullptr;
        atual->dir = nullptr;
        
        if(num > (pai->info)){
            //se for maior que o local "pai", insere na direita
            pai->dir = atual;
        } 
        else {
            //se for menor que o local "pai", insere na esquerda
            pai->esq = atual;
        }
    }

void emOrdem(Nodo * raiz){
        if(raiz == nullptr){
            return; //condição de parada!
        }
        //imprimindo em ordem = esq , dir , raiz
        emOrdem(raiz->esq); //recursão!
        //chama a própria função, até achar menor elemento
        cout<<raiz->info<<endl;
        //imprime o menor 
        emOrdem(raiz->dir);
        //chama a própria função, até achar maior elemento
        //passa para o prox (ao lado direito)
    }

 int contarFolhas(Nodo *raiz) {
        if (raiz == nullptr) return 0;
        if (raiz->esq == nullptr && raiz->dir == nullptr) return 1;
        return contarFolhas(raiz->esq) + contarFolhas(raiz->dir);
    }

    bool estrita(Nodo *raiz) {
        if (raiz == nullptr) return true;

        if ((raiz->esq == nullptr && raiz->dir != nullptr) ||
            (raiz->esq != nullptr && raiz->dir == nullptr)) {
            return false;
        }

        return estrita(raiz->esq) && estrita(raiz->dir);
    }
    
};
